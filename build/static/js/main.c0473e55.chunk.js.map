{"version":3,"sources":["drag.js","App.js","index.js"],"names":["getPageXY","event","targetTouches","length","x","pageX","y","pageY","defaultDragAction","selector","offset","target","closest","isNaN","element","parent","tagName","parentNode","getComputedStyle","getPropertyValue","getNonStaticParent","getBoundingClientRect","fixLeft","left","fixTop","top","style","noDefault","preventDefault","startTracking","move","end","drag","drop","body","document","type","addEventListener","passive","removeEventListener","App","dragMe","cancelTracking","timeOut","dragRef","useRef","flashDiv","checkForDrag","innerHTML","triggerDelta","trigger2","Math","abs","Promise","resolve","reject","startX","startY","deltaX","deltaY","setTimeout","detectMovement","then","reset","startDrag","catch","useEffect","current","clearTimeout","classList","remove","text","add","once","className","onMouseDown","ref","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.c0473e55.chunk.js","sourcesContent":["// MOUSE/TOUCH EVENT FUNCTIONS ///\n// https://gist.github.com/blackslate/6f77d3acd2edc2a286cff6d607cf3ce8\n\n/**\n * DETECT MOVEMENT\n * ---------------\n * Sometimes you want a simple click to perform one action and a drag\n * on the same element to perform a different action. You can create two\n * methods, (say) startDrag() and clickAction(), and use the following\n * function (plus the functions below) to determine which of the two\n * actions will be triggered.\n *\n *  const checkForDrag = (event) => {\n *    event.preventDefault()\n *\n *    detectMovement(event, 10, 250) //\n *    .then(\n *      () => startDrag(event) // use same event to start drag action\n *     )\n *    .catch(clickAction)\n *  }\n *\n * startDrag will be called if the mouse or touch point moves 10 pixels\n * or more within 250 milliseconds. clickAction will be called if there\n * is no movement within this time, or if the mouse/touch pressure is\n * released before this time.\n *\n * SET TRACKED EVENTS\n * ------------------\n * When dragging an element, you generally want one function to be\n * called for any movement, and another to be triggered when the element\n * is dropped. You don't want to have to create separate code for\n * mouse events and touch events, even if these events generate\n * the current x and y positions in different ways.\n *\n * The startTracking() function allows you to provide a starting\n * event (mouseDown or touchStart) and two functions that should be\n * called: one for mousemove|touchmove and the other for mouseup|\n * touchend.\n *\n * X and Y COORDINATES\n * -------------------\n * You can use getPageXY() to get the current mouse position or the\n * position of the first touch point, without worrying about whether\n * the input is from a mouse or a touch screen.\n *\n * let dragMe = <your draggable element>\n *   , cancelTracking // set to function to stop dragging\n *\n * const drop = () => {\n *   canceTracking()\n *   // Do whatever needs to be done when the element is dropped\n * }\n *\n * const startDrag = (event) => {\n *   const { x, y } = getPageXY(event)\n *   const { left, top } = dragMe.getBoundingClientRect()\n *   offset = { x: left - x, y: top - y }\n *\n *   const options = {\n *     event\n *   , drop\n *   }\n *\n *   // Store the callback functions to remove the event listeners\n *   // from the element when the drag is complete.\n *   cancelTracking = startTracking(options)\n * }\n *\n * const checkForDrag = (event) => {\n *   event.preventDefault()\n *\n *   detectMovement(event, 16)\n *   .then(() => startDrag(event) )\n *   .catch(clickAction)\n * }\n *\n * ===============================================================\n * NOTE FOR REACT USERS CREATING WEB APPS FOR TOUCH SCREEN DEVICES\n * ===============================================================\n * React refuses to add non-passive (cancellable) event listeners for\n * touchstart. With a passive event listener, the whole page is likely\n * to move at the same time as the dragged element, which is probably\n * not what you want.\n *\n * As a result, you should NOT use React to pass an onTouchStart\n * function the same way that you would pass an onMouseDown function to\n *  your draggable element.\n *\n * Instead, you need to apply your touchstart event listener directly\n * to the DOM element that you want to drag with useEffect, as shown\n * below.\n *\n * const dragRef = useRef()\n *\n * return (\n *   <main>\n *     <div\n *       onMouseDown={checkForDrag}\n *       ref={dragRef}\n *     />\n *   </main>\n * );\n *\n * useEffect(() => {\n *   dragMe = dragRef.current\n *   dragMe.addEventListener(\"touchstart\", checkForDrag, false)\n * })\n */\n\n const getPageXY = (event) => {\n  if (event.targetTouches && event.targetTouches.length) {\n    event = event.targetTouches[0] || {}\n  }\n\n  return { x: event.pageX, y: event.pageY }\n}\n\n\n\n/**\n * Returns a promise which will be:\n * * resolved if the mouse or touch moves more than triggerDelta\n *   pixels in any direction\n * * rejected if the mouse is released or the touch gesture ends before\n *   moving that far, or if <timeOut> number of milliseconds elapses\n *   before any movement occurs.\n *\n * @param  {event}  event should be a mousedown or touchstart event\n * @param  {number} triggerDelta should be the number of pixels of\n *                          movement that will resolve the promise\n * @param  {number} timeOut may be a number of milliseconds. Defaults\n *                          to 250. Use 0 for no timeOut rejection.\n *\n * @return  {promise}\n */\nexport const detectMovement = (event, triggerDelta, timeOut) => {\n  const trigger2 = triggerDelta * triggerDelta\n  timeOut = isNaN(timeOut) ? 250 : Math.abs(timeOut)\n\n  function movementDetected(resolve, reject) {\n    const { x: startX, y: startY } = getPageXY(event)\n    const options = { event, drag, drop }\n    const cancelTracking = startTracking(options)\n\n    // Check if the mouse/touch has moved more than triggerDelta\n    // pixels in any direction, and resolve promise if so.\n    function drag(event) {\n      const { x, y } = getPageXY(event)\n      const deltaX = startX - x\n      const deltaY = startY - y\n      const delta2 = (deltaX * deltaX + deltaY * deltaY)\n\n      if (delta2 > trigger2) {\n        cancelTracking()\n        resolve()\n      }\n    }\n\n    // Reject promise if the mouse is released before the mouse/touch\n    // moved triggerDelta pixels in any direction.\n    function drop() {\n      cancelTracking()\n      reject(\"release\")\n    }\n\n    if (timeOut) {\n      setTimeout(() => reject(\"timeOut\"), timeOut)\n    }\n  }\n\n  return new Promise(movementDetected)\n}\n\n\n/**\n * @param {DOMElement} element\n * @returns  element's closest parent which has a position other than\n *           static\n */\nconst getNonStaticParent = (element) => {\n  let parent\n  while (element.tagName !== \"BODY\" && (parent = element.parentNode)) {\n    const style = getComputedStyle(parent)\n    if (style.getPropertyValue(\"position\") !== \"static\") {\n      break\n    }\n\n    element = parent\n  }\n\n  return parent\n}\n\n\n\n/**\n * If no drag function is supplied, move the target (or its parent)\n * with the mouse or touch\n *\n * @param {MouseEvent | TouchEvent} event\n * @param {String?} selector\n *                  If selector is a string, it will be used to find\n *                  the closest matching parent (or the target itself)\n *                  as the element to drag\n * @param {Objec?}  offset\n *                  If offset is an object with the format\n *                  { x: <Number>, y: <Number> }, then it will be used\n *                  for defining the offset from the drag point to the\n *                  top left of the dragged element.\n * @returns         a function in a closure, which knows which target\n *                  and offset to use \n */\nconst defaultDragAction = (event, selector, offset) => {\n  const target = (typeof selector === \"string\")\n               ? event.target.closest(selector) // select an ancestor\n               : event.target\n\n  const offsetGiven = typeof offset === \"object\"\n                   && !isNaN(offset.x)\n                   && !isNaN(offset.y)\n\n  if (!offsetGiven) {\n    // Move target relative to its closest non-static parent\n    const fix = getNonStaticParent(target)\n    const { left: fixLeft, top: fixTop } = fix.getBoundingClientRect()\n    const { x, y } = getPageXY(event)\n    const { left, top } = target.getBoundingClientRect()\n    offset = { x: left - fixLeft - x , y: top - fixTop - y }\n  }\n\n  const drag = (event) => {\n    const { x, y } = getPageXY(event)\n    target.style.left = (offset.x + x )+ \"px\"\n    target.style.top =  (offset.y + y )+ \"px\"\n  }\n\n  return drag\n}\n\n\n\n// The prevent default function needs to be outside startTracking\n// so that the exact same listener function (rather than a duplicate)\n// can be  removed later.\nconst noDefault = (event) => event.preventDefault()\n\n\n\n/**\n * Starts a drag and drop operation, and follows it through to the end.\n *\n * @param {Object}\n *          event: may be either a MouseDown event or a TouchStart event\n *           drag: may be a custom function to call for dragging. If\n *                 not, a generic function will be used. It may also be\n *                 a CSS selector to define which parent of the clicked\n *                 target should be dragged.\n *           drop: a callback function that will be called when the\n *                 dragging stops\n *         offset: may be an object of the form { x: Number, y: Number}\n *                 to be used by the defaultDragAction function.\n *\n * @returns a function to call to cancelTracking\n */\nexport const startTracking = ({ event, drag, drop, offset }) => {\n  const body = document.body\n  const dragOption = { passive: false } // capture is false by default\n\n  let move\n  , end\n\n  if (event.type === \"touchstart\") {\n    move  = \"touchmove\"\n    end   = \"touchend\"\n  } else {\n    move  = \"mousemove\"\n    end   = \"mouseup\"\n  }\n\n  switch (typeof drag) {\n    case \"function\":\n      // Use the custom function\n    break\n    default: // case \"string\":\n      drag = defaultDragAction(event, drag, offset)\n    break\n  }\n\n  body.addEventListener(move, drag, false)\n  body.addEventListener(end, drop, false)\n  // Prevent the page scrolling during drag, on touch devices\n  document.addEventListener(\"touchstart\", noDefault, dragOption)\n\n  const cancelTracking = () => {\n    body.removeEventListener(move, drag, false)\n    body.removeEventListener(end, drop, false)\n    // Restore page scrolling on touch devices now that drag is over\n    document.removeEventListener(\"touchstart\", noDefault)\n  }\n\n  return cancelTracking\n}","import React, { useEffect, useRef } from 'react'\nimport './App.css';\n\nimport {\n    detectMovement\n  , startTracking\n} from './drag'\n\n\nfunction App() {\n  const dragRef = useRef()\n\n  let dragMe\n    , cancelTracking\n    , timeOut\n\n\n  const drop = () => {\n    cancelTracking()\n    dragMe.style = {}\n    flashDiv(\"You dragged me!\")\n  }\n\n\n  const startDrag = (event) => {  \n    reset()\n    dragMe.innerHTML = \"Wheeee!\"\n\n    const options = {\n      event\n    , drop\n    }\n\n    cancelTracking = startTracking(options)\n  }\n\n\n  const checkForDrag = (event) => {\n    event.preventDefault()\n\n    dragMe.innerHTML = \"Drag me!\"\n\n    detectMovement(event, 16)\n    .then(() => startDrag(event))\n    .catch(flashDiv)\n  }\n\n\n  useEffect(() => {\n    // eslint-disable-next-line\n    dragMe = dragRef.current\n    dragMe.addEventListener(\"touchstart\", checkForDrag, false)\n  })\n\n\n  const reset = () => {\n    clearTimeout(timeOut)\n    dragMe.classList.remove(\"flash\")\n    dragMe.innerHTML = \"Drag me!\"\n  }\n  \n  \n  const flashDiv = (text) => {\n    dragMe.classList.add(\"flash\")\n  \n    if (text === \"timeOut\") { // called by reject\n      clearTimeout(timeOut)\n      const options = { once: true }\n      document.body.addEventListener(\"mouseup\", reset, options)\n  \n    } else {\n      timeOut = setTimeout(reset, 1000)\n    }\n  \n    dragMe.innerHTML = text\n  }\n\n\n  return (\n    <main>\n      <div className=\"red\"></div>\n      <div className=\"green\"></div>\n      <div className=\"blue\"></div>\n\n      <div className=\"container\">\n        <div\n          className=\"draggable unselectable\"\n          onMouseDown={checkForDrag}\n          ref={dragRef}\n        >\n          Drag me!\n        </div>\n      </div>\n    </main>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}